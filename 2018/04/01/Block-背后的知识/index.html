<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="iOS," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="本文针对使用过 Block 结构，对 Block 的背后实现不太了解的读者。这两天刚看完有关 Block 的一些内容，做一个小结，主要回答以下问题：

都说 Block 可以看做是 Objective-C 中的对象，它的本质到底是什么？
Block 使用起来很方便，因为它能捕捉到其外部的变量，并进行访问和修改，这是怎么实现的？
Block 为什么要用 copy 修饰符？
Block 的循环引用到底">
<meta property="og:type" content="article">
<meta property="og:title" content="Block 几个问题--底层机制初探**">
<meta property="og:url" content="http://yoursite.com/2018/04/01/Block-背后的知识/index.html">
<meta property="og:site_name" content="大脸儿">
<meta property="og:description" content="本文针对使用过 Block 结构，对 Block 的背后实现不太了解的读者。这两天刚看完有关 Block 的一些内容，做一个小结，主要回答以下问题：

都说 Block 可以看做是 Objective-C 中的对象，它的本质到底是什么？
Block 使用起来很方便，因为它能捕捉到其外部的变量，并进行访问和修改，这是怎么实现的？
Block 为什么要用 copy 修饰符？
Block 的循环引用到底">
<meta property="og:updated_time" content="2018-04-10T14:15:21.165Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Block 几个问题--底层机制初探**">
<meta name="twitter:description" content="本文针对使用过 Block 结构，对 Block 的背后实现不太了解的读者。这两天刚看完有关 Block 的一些内容，做一个小结，主要回答以下问题：

都说 Block 可以看做是 Objective-C 中的对象，它的本质到底是什么？
Block 使用起来很方便，因为它能捕捉到其外部的变量，并进行访问和修改，这是怎么实现的？
Block 为什么要用 copy 修饰符？
Block 的循环引用到底">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 6284716645889869000,
      author: '博主'
    }
  };
</script>

  <title> Block 几个问题--底层机制初探** | 大脸儿 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?3188724465a6f7695bd8b4ae49fbe857";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">大脸儿</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">hexintao</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Block 几个问题--底层机制初探**
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-04-01T03:27:21+08:00" content="2018-04-01">
              2018-04-01
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/04/01/Block-背后的知识/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/04/01/Block-背后的知识/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2018/04/01/Block-背后的知识/" class="leancloud_visitors" data-flag-title="Block 几个问题--底层机制初探**">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>本文针对使用过 <code>Block</code> 结构，对 <code>Block</code> 的背后实现不太了解的读者。<br>这两天刚看完有关 <code>Block</code> 的一些内容，做一个小结，主要回答以下问题：</p>
<ol>
<li>都说 Block 可以看做是 Objective-C 中的对象，它的本质到底是什么？</li>
<li>Block 使用起来很方便，因为它能捕捉到其外部的变量，并进行访问和修改，这是怎么实现的？</li>
<li>Block 为什么要用 copy 修饰符？</li>
<li>Block 的循环引用到底是怎么回事？怎么解决？  </li>
</ol>
<p>这些问题上网一搜一大堆，十分常见，希望这篇从稍微底层一点的解释，能给你一点小小的惊喜。<br><a id="more"></a></p>
<h4 id="问题-1-Block-的本质"><a href="#问题-1-Block-的本质" class="headerlink" title="问题 1. Block 的本质"></a>问题 1. Block 的本质</h4><p>最简单的一个 Block 定义：</p>
<figure class="highlight mm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> (^aBlock)(<span class="keyword">void</span>) = ^ &#123;</span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">@"这是一个最简单的 block。"</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上述形式是我们平时简化之后的写法，其实最完整的写法是：</p>
<figure class="highlight mm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> (^aBlock)(<span class="keyword">void</span>) = ^<span class="keyword">void</span>(<span class="keyword">void</span>) &#123;</span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">@"这是一个最简单的 block。"</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>使用 <code>clang -rewrite-objc main.m</code> 命令将其转换为 .cpp 文件后，可以看到代码增加到一万多行，我们直接拉到最底部，可以找到 <code>main</code> 的定义：</p>
<figure class="highlight mm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">void</span>(*aBlock)(<span class="keyword">void</span>)= ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这。。。太麻烦了，不过静下心来：先看左边，<code>void(*aBlock)(void)</code> 是典型的 C 函数指针，也就是说，<code>aBlock</code> 是一个变量，里边存储的是一个函数的地址，而这个函数是不带参数不带返回值的类型。再看右边，先不管前边的好多层括号，<code>&amp;</code> 是取地址的操作，也就是取 <code>__main_block_impl_0</code> 的地址并赋值。前边的 <code>void(*)()</code> 是类型的强转，为了和左边要求的函数类型相匹配。后边的括号相当于是 <code>__main_block_impl_0</code> 的入参。所以稍微简化一下：</p>
<figure class="highlight mm"><table><tr><td class="code"><pre><span class="line">__main_block_impl_0 temp = __main_block_impl_0( (<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA);</span><br><span class="line">aBlock = &amp;temp;</span><br></pre></td></tr></table></figure>
<p>到这，离第一个问题的答案已经不远了，<code>Block</code> 的本质这不就是一个指向 <code>__main_block_impl_0</code> 类型的指针嘛。至于 <code>__main_block_impl_0</code> 的定义，我们全局搜索一下就可以找到：</p>
<figure class="highlight mm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</span><br><span class="line">  <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc;</span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="keyword">int</span> flags=<span class="number">0</span>) &#123;</span><br><span class="line">    impl.isa = &amp;_<span class="built_in">NSConcreteStackBlock</span>;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>结构体。其实也不惊讶，<code>Objective-C</code> 中的类和对象本质不都是结构体嘛。这个结构体看起来也比较复杂，其实它只有两个成员变量：</p>
<figure class="highlight mm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> __block_impl impl;</span><br><span class="line"><span class="keyword">struct</span> __main_block_desc_0* Desc; 	<span class="comment">// 指针变量，指向  __main_block_desc_0 类型</span></span><br></pre></td></tr></table></figure>
<p>剩下的一坨是结构体的初始化方法（构造方法）。对照前边的 <code>main</code> 的代码，<code>__main_block_func_0</code> 对应结构体初始化方法中的 <code>fp</code>，<code>__main_block_desc_0_DATA</code> 对应初始化方法中的 <code>desc</code>，<code>flags</code> 默认是 0。通过这两个参数，我们看一下这个结构体是怎么初始化的。先看 <code>__block_impl</code> 的定义：</p>
<figure class="highlight mm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> __block_impl &#123;</span><br><span class="line">    <span class="keyword">void</span> *isa;      <span class="comment">// isa 指针</span></span><br><span class="line">    <span class="keyword">int</span> Flags;      <span class="comment">// 标志位</span></span><br><span class="line">    <span class="keyword">int</span> Reserved;   <span class="comment">// 保留位</span></span><br><span class="line">    <span class="keyword">void</span> *FuncPtr;  <span class="comment">// 这不是函数指针！而是指针函数，也就是带返回值的函数，返回值是一个万能类型的指针 void *</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>经过初始化之后，变化如下：</p>
<figure class="highlight mm"><table><tr><td class="code"><pre><span class="line">impl.isa = &amp;_<span class="built_in">NSConcreteStackBlock</span>;		<span class="comment">// block 的类型</span></span><br><span class="line">impl.Flags = flags;						<span class="comment">// 默认为 0</span></span><br><span class="line">impl.FuncPtr = fp;						<span class="comment">// __main_block_func_0</span></span><br><span class="line">Desc = desc;							<span class="comment">// __main_block_desc_0_DATA</span></span><br></pre></td></tr></table></figure>
<p><code>__main_block_func_0</code> 和 <code>__main_block_desc_0_DATA</code> 又是啥？继续搜索：</p>
<figure class="highlight mm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</span><br><span class="line">	<span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__<span class="built_in">NSConstantStringImpl__var_folders_90_cs8g8nkx25dckdwfnf1n66kr0000gn_T_main_00297a_mi_0</span>);  <span class="comment">// __main_block_func_0 中仅有一句 NSLog，这不正是 block 的定义吗？打印的结果是一个全局函数，搜索即可找到该函数的定义如下：</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> __<span class="built_in">NSConstantStringImpl</span> __<span class="built_in">NSConstantStringImpl__var_folders_90_cs8g8nkx25dckdwfnf1n66kr0000gn_T_main_00297a_mi_0</span> __attribute__ ((section (<span class="string">"__DATA, __cfstring"</span>))) = &#123;__<span class="built_in">CFConstantStringClassReference</span>,<span class="number">0x000007c8</span>,<span class="string">"\350\277\231\346\230\257\344\270\200\344\270\252\346\234\200\347\256\200\345\215\225\347\232\204 block\343\200\202"</span>,<span class="number">33</span>&#125;; <span class="comment">// 翻译过来肯定是：这是一个最简单的 block。</span></span><br></pre></td></tr></table></figure>
<p>到这里，我们可以看到，<code>aBlock</code> 的声明和实现就关联起来了，引用的关系大致为：</p>
<p><code>aBlock</code> -&gt; <code>__main_block_impl_0</code> -&gt; <code>__block_impl impl.FuncPtr</code> -&gt; <code>__main_block_func_0</code>。</p>
<p>再看 <code>__main_block_desc_0_DATA</code>：</p>
<figure class="highlight mm"><table><tr><td class="code"><pre><span class="line">__main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> __main_block_impl_0)&#125;;</span><br></pre></td></tr></table></figure>
<p>一个全局的函数，从字面看，存储着 <code>__main_block_impl_0</code> 的大小信息，第一个 <code>0</code> 意义暂未知。</p>
<p>来一个总结：</p>
<ul>
<li><code>__main_block_impl_0</code>：结构体类型。定义了 <code>Block</code> 的具体类型，也算是 <code>Block</code> 的本质。</li>
<li><code>__main_block_func_0</code>： 全局的静态函数，是 <code>Block</code> 的具体实现。</li>
<li><code>__main_block_desc_0_DATA</code>：全局函数，相当于是 <code>Block</code> 的额外信息描述。</li>
<li><code>__block_impl</code>：<code>__main_block_impl_0</code> 内部的一个成员变量，把 <code>__main_block_impl_0</code> 和 <code>__main_block_func_0</code> 连接起来。</li>
</ul>
<p>这里边的名称也是有规律的，基本是按照： <code>Block</code> 所属的方法名+在其所属方法中的定义顺序。例如，例子中我们的 <code>Block</code> 是定义在 <code>main</code> 方法中的第一个 <code>Block</code>。</p>
<p><code>OC</code> 中所有的对象本质都是结构体，其都有一个 <code>isa</code> 指针，指向自己的类型（其实是类对象，也是结构体，类对象的 <code>isa</code> 指向其元类），通过以上我们也可以看到 <code>block</code> 内部也有 <code>isa</code> 指针，所以也可以把 <code>block</code> 当做对象来看待，例子中的 <code>block</code> 当然就是 <code>_NSConcreteStackBlock</code> 类型，位于栈区的 <code>block</code>。</p>
<p>除此以外，还有 <code>_NSConcreteGlobalBlock</code> 和 <code>_NSConcreteMallocBlock</code> 类型，顾名思义，前者是全局类型，后者则位于堆区。其中如果 <code>block</code> 定义时就是全局类型，或者其内部没有捕获任何外部的局部变量，此时的 <code>block</code> 就是 <code>_NSConcreteGlobalBlock</code> 类型。除此以外，其他定义的 <code>block</code> 默认就是 <code>_NSConcreteStackBlock</code> 类型，而一旦对后者执行 <code>copy</code> 操作，其类型就会变为 <code>_NSConcreteMallocBlock</code>。</p>
<h4 id="问题-2-Block-捕获并修改外部变量"><a href="#问题-2-Block-捕获并修改外部变量" class="headerlink" title="问题 2. Block 捕获并修改外部变量"></a>问题 2. Block 捕获并修改外部变量</h4><h5 id="2-1-基本类型变量的捕获"><a href="#2-1-基本类型变量的捕获" class="headerlink" title="2.1 基本类型变量的捕获"></a>2.1 基本类型变量的捕获</h5><p>可是平时我们使用 <code>block</code> 时，基本都会在 <code>block</code> 中用到外部变量，我们再看一个简单的例子：</p>
<figure class="highlight mm"><table><tr><td class="code"><pre><span class="line">__block <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> valNoBlock = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">void</span> (^blk)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">	val = valNoBlock + <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line">blk();</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%d"</span>, val);</span><br></pre></td></tr></table></figure>
<p>我们都知道，如果 <code>val</code> 声明时没有使用 <code>__block</code> 进行修饰，编译就会报错：</p>
<p><code>Variable is not assignable (missing __block type specifier)</code></p>
<p>而 <code>block</code> 内部只是读取并没有修改 <code>valNoBlock</code> 的值，所以就不用加 <code>__block</code> 修饰符。使用了 <code>__block</code> 之后，怎么就能修改外部的局部变量了？同样，我们依然对上述代码进行 <code>clang -rewrite-objc main.m</code> 操作。</p>
<p>拉到最底部，看 <code>main</code> 方法中两个变量的定义：</p>
<figure class="highlight mm"><table><tr><td class="code"><pre><span class="line">__attribute__((__blocks__(<span class="keyword">byref</span>))) __Block_byref_val_0 val = &#123;(<span class="keyword">void</span>*)<span class="number">0</span>,(__Block_byref_val_0 *)&amp;val, <span class="number">0</span>, <span class="keyword">sizeof</span>(__Block_byref_val_0), <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> valNoBlock = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<p>好复杂！简化一下：</p>
<figure class="highlight mm"><table><tr><td class="code"><pre><span class="line">__Block_byref_val_0 val = &#123;(<span class="keyword">void</span>*)<span class="number">0</span>,(__Block_byref_val_0 *)&amp;val, <span class="number">0</span>, <span class="keyword">sizeof</span>(__Block_byref_val_0), <span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>加了 <code>__block</code> 修饰符的 <code>val</code> 变成了这么大一坨，类型也不再是简单的 <code>int</code> 了，而是 <code>__Block_byref_val_0</code>，这是个什么鬼？搜索得到定义：</p>
<figure class="highlight mm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> __Block_byref_val_0 &#123;</span><br><span class="line">	<span class="keyword">void</span> *__isa;</span><br><span class="line">	__Block_byref_val_0 *__forwarding;</span><br><span class="line">	<span class="keyword">int</span> __flags;</span><br><span class="line">	<span class="keyword">int</span> __size;</span><br><span class="line">	<span class="keyword">int</span> val;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>没错，又是结构体。经过上述赋值，整个结构体的值变化如下：</p>
<figure class="highlight mm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> __Block_byref_val_0 &#123;</span><br><span class="line">	<span class="keyword">void</span> *__isa;						<span class="comment">// (void*)0</span></span><br><span class="line">	__Block_byref_val_0 *__forwarding;	<span class="comment">// &amp;val</span></span><br><span class="line">	<span class="keyword">int</span> __flags;						<span class="comment">// 0</span></span><br><span class="line">	<span class="keyword">int</span> __size;							<span class="comment">// sizeof(__Block_byref_val_0)</span></span><br><span class="line">	<span class="keyword">int</span> val;							<span class="comment">// 0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们这里重点看 <code>__forwarding</code> 和最后一个 <code>int val</code>。前者是一个指针，指向自己。后者保存的是该变量的初始值。而作为对比，<code>valNoBlock</code> 则依旧是简单的 <code>int</code> 类型，没发生什么变化。</p>
<p>我们接着往下看 <code>block</code> 的定义部分，像第一个问题中一样，简化之后是：</p>
<figure class="highlight mm"><table><tr><td class="code"><pre><span class="line">__main_block_impl_0 temp = __main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, valNoBlock, (__Block_byref_val_0 *)&amp;val, <span class="number">570425344</span>);</span><br><span class="line">blk = &amp;temp;</span><br></pre></td></tr></table></figure>
<p>比第一个例子中多了些东西，我们看一下 <code>__main_block_impl_0</code> 的定义：</p>
<figure class="highlight mm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</span><br><span class="line">  <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc;</span><br><span class="line">  <span class="keyword">int</span> valNoBlock;</span><br><span class="line">  __Block_byref_val_0 *val; <span class="comment">// by ref</span></span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="keyword">int</span> _valNoBlock, __Block_byref_val_0 *_val, <span class="keyword">int</span> flags=<span class="number">0</span>) : valNoBlock(_valNoBlock), val(_val-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa = &amp;_<span class="built_in">NSConcreteStackBlock</span>;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>相比第一个例子，多了两个成员变量：<code>int valNoBlock</code> 和 <code>__Block_byref_val_0 *val</code>，这正好和 <code>blk</code> 中使用到的两个变量相对应。这里的 <code>valNoBlock(_valNoBlock), val(_val-&gt;__forwarding)</code> 语法不懂什么意思，希望知道的可以告知。除了和第一个例子一样的初始化之外，加上前边的 <code>block</code> 的定义，我们可以看到：没有 <code>__block</code> 修饰的 <code>valNoBlock</code> 是直接把值传了进去，<code>block</code> 内部会有一个同样类型的变量接收其值，而 <code>__block</code> 类型的变量，<code>block</code> 内部对应有一个指针变量，存储着变量结构体的地址。到此，<code>__block</code> 的面纱我们基本也揭开了。</p>
<p>但是，<code>block</code> 还没有执行呢，我们接着往下看 <code>block</code> 定义完之后是怎么调用的。很简单的一句：</p>
<figure class="highlight mm"><table><tr><td class="code"><pre><span class="line">((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</span><br></pre></td></tr></table></figure>
<p>通过第一个例子我们知道，<code>block</code> 的实现是形如 <code>__main_block_func_0</code> 的函数，而它的地址正是存放在 <code>block</code> 中的成员变量 <code>impl.FuncPtr</code> 中的，所以这一句就是直接调用 <code>__main_block_func_0</code> 即 <code>block</code> 的实现函数。我们看一下 <code>__main_block_func_0</code> 的实现：</p>
<figure class="highlight mm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</span><br><span class="line">	__Block_byref_val_0 *val = __cself-&gt;val; 	<span class="comment">// bound by ref</span></span><br><span class="line">	<span class="keyword">int</span> valNoBlock = __cself-&gt;valNoBlock;		<span class="comment">// bound by copy</span></span><br><span class="line">	(val-&gt;__forwarding-&gt;val) = valNoBlock + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>__cself</code> 类似于 <code>OC</code> 中的 <code>self</code>，在这里就是前边执行 <code>block</code> 时传入的 <code>blk</code>，或者更彻底的，就是那个 <code>__main_block_impl_0</code> 类型的结构体。从这里，我们更能直观的看到，当 <code>block</code> 执行时，有没有 <code>__block</code> 修饰的变量的区别。<code>val</code> 是个指针变量，取值自 <code>__main_block_impl_0</code> 结构体中的 <code>val</code> 变量，而后者的值是在 <code>block</code> 定义时指定的，存储的是 <code>__block</code> 类型变量，即 <code>__Block_byref_val_0</code> 结构体的地址。说白了，经过层层传递，终于把 <code>__block</code> 类型变量的地址传递到了 <code>block</code> 的实现函数中。</p>
<p>接着，<strong>重新又定义</strong>了一个 <code>int</code> 类型的 <code>valNoBlock</code>，并把外界变量的值赋给该变量，所以不加 <code>__block</code> 修饰的变量，如果在 <code>block</code> 内部对其修改，外界变量的值是不会跟着变的，它们是复制出来的两个完全独立的变量。这里有个小问题，例子中是 <code>int</code> 类型的变量，所以直接赋值没什么疑问，如果换作是对象，这一步对应的是什么操作呢？<code>copy</code>？<code>retain</code>？</p>
<p>最后一句：</p>
<p><code>(val-&gt;__forwarding-&gt;val) = valNoBlock + 1;</code></p>
<p><code>(val-&gt;__forwarding-&gt;val)</code> 指向的是 <code>__Block_byref_val_0</code> 结构体中 <code>int</code> 类型的 <code>val</code> 成员变量，前边咱们提到正是它保存着 <code>__block</code> 类型变量的初始值，现在，修改的也正是它的值。所以，它变化，外界变量的值也会变化，因为它们指向的就是同一个结构体中的成员变量。</p>
<h5 id="2-2-对象类型的捕获"><a href="#2-2-对象类型的捕获" class="headerlink" title="2.2 对象类型的捕获"></a>2.2 对象类型的捕获</h5><p>例子：</p>
<figure class="highlight mm"><table><tr><td class="code"><pre><span class="line">__block <span class="built_in">NSString</span> *str = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@"</span>, <span class="string">@"Hello"</span>];</span><br><span class="line">__block <span class="keyword">id</span> aObj;</span><br><span class="line"><span class="built_in">NSString</span> *strNoBlock = <span class="string">@"world!"</span>;</span><br><span class="line"><span class="keyword">void</span> (^blk)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">	str = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@ %@"</span>, str, strNoBlock];</span><br><span class="line">	aObj = str;</span><br><span class="line">&#125;;</span><br><span class="line">blk();</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, str);</span><br></pre></td></tr></table></figure>
<p>这里使用 <code>stringWithFormat:</code> 初始化是因为 <code>__block</code> 类型的 <code>NSString</code> 如果通过字符串直接赋值，<code>clang</code> 过不去。<code>aObj</code> 存在的意义是 <code>clang</code> 之后的代码比 <code>NSString</code> 的简单，易读。</p>
<p><code>__block</code> 类型的 <code>NSString</code> 就会变成如下的结构体：</p>
<figure class="highlight mm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> __Block_byref_str_0 &#123;</span><br><span class="line"> 	 <span class="keyword">void</span> *__isa;</span><br><span class="line">	__Block_byref_str_0 *__forwarding;</span><br><span class="line">	 <span class="keyword">int</span> __flags;</span><br><span class="line">	 <span class="keyword">int</span> __size;</span><br><span class="line">	 <span class="keyword">void</span> (*__Block_byref_id_object_copy)(<span class="keyword">void</span>*, <span class="keyword">void</span>*);</span><br><span class="line">	 <span class="keyword">void</span> (*__Block_byref_id_object_dispose)(<span class="keyword">void</span>*);</span><br><span class="line">	 <span class="built_in">NSString</span> *str;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对比基本类型的变量，多了两个函数指针：<code>__Block_byref_id_object_copy</code> 和 <code>__Block_byref_id_object_dispose</code>。 最后一个 <code>NSString *str</code>，同样也是为了存储值，只不过本例中是对象，要注意一点，这个对象的内存修饰符是默认的 <code>__strong</code>，而且因为是对象，所以它的内存也是由编译器管理的，至于怎么管理，下边会说。</p>
<p><code>__block</code> 变量定义为，以 <code>aObj</code> 为例，简化之后为：</p>
<figure class="highlight mm"><table><tr><td class="code"><pre><span class="line">__Block_byref_aObj_1 aObj = &#123;(<span class="keyword">void</span>*)<span class="number">0</span>,(__Block_byref_aObj_1 *)&amp;aObj, <span class="number">33554432</span>, <span class="keyword">sizeof</span>(__Block_byref_aObj_1), __Block_byref_id_object_copy_131, __Block_byref_id_object_dispose_131&#125;;</span><br></pre></td></tr></table></figure>
<p>同样，传的也是自身的地址，对应前边两个函数指针，这里传递的是两个全局静态函数：</p>
<figure class="highlight mm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __Block_byref_id_object_copy_131(<span class="keyword">void</span> *dst, <span class="keyword">void</span> *src) &#123;</span><br><span class="line"> _Block_object_assign((<span class="keyword">char</span>*)dst + <span class="number">40</span>, *(<span class="keyword">void</span> * *) ((<span class="keyword">char</span>*)src + <span class="number">40</span>), <span class="number">131</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __Block_byref_id_object_dispose_131(<span class="keyword">void</span> *src) &#123;</span><br><span class="line"> _Block_object_dispose(*(<span class="keyword">void</span> * *) ((<span class="keyword">char</span>*)src + <span class="number">40</span>), <span class="number">131</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整个流程大致为：<code>__block</code> 类型的对象，其结构体中会绑定两个函数的地址，在 <code>Block</code> 定义时，对象的结构体就传入了 <code>Block</code> 中。当 <code>Block</code> 从栈区被拷贝到堆区时，<code>__block</code> 类型的对象的 <code>__Block_byref_id_object_copy_131</code> 方法，即 <code>_Block_object_assign</code> 方法就会自动调用，相当于 <code>Block</code> 持有了该 <code>__block</code> 对象，而当 <code>Block</code> 从堆区释放时，<code>__block</code> 对象的 <code>__Block_byref_id_object_dispose_131</code> 方法，即 <code>_Block_object_dispose</code> 就会自动调用，解除 <code>Block</code> 对 <code>__block</code> 对象的持有。也就是说，系统通过 <code>Block</code> 的拷贝和释放时机，完成对 <code>Block</code> 捕获的对象类型的内存管理。</p>
<p>使用时，为了可以在 <code>block</code> 内对外部的变量进行修改，简简单单的一个 <code>__block</code> 修饰符，其背后可以说发生了翻天覆地的变化。我们这里说的只是针对局部自动变量，对于全局变量、全局静态变量以及局部静态变量的修改，这里并未涉及，思路完全一样，可以自己动手分析。</p>
<h4 id="问题-3-Block-为什么要用-copy-修饰符？"><a href="#问题-3-Block-为什么要用-copy-修饰符？" class="headerlink" title="问题 3. Block 为什么要用 copy 修饰符？"></a>问题 3. Block 为什么要用 copy 修饰符？</h4><p>经常使用 <code>Block</code> 的人都知道，如果要创建一个 <code>Block</code> 类型的属性变量，要使用 <code>copy</code> 修饰符。为什么呢？使用其他修饰符，例如 <code>strong</code> 会有什么后果？</p>
<p>我们先来想这个问题，为什么要使用属性变量呢？几乎绝大部分时候都是为了要在该对象的定义域之外使用该变量，对于 <code>Block</code> 同样如此。通过前边两个问题，我们还知道，对于 <code>_NSConcreteStackBlock</code> 类型的 <code>Block</code> 来说，不管是 <code>Block</code> 还是 <code>__block</code> 类型的变量，他们本质都是结构体变量，而且是位于栈上的结构体。所以，出了定义的作用域之后，它们的内存就会被释放掉。所以为了不让它们释放掉，就需要将其拷贝到堆区，由我们自己控制何时释放，当然，现在都是系统通过 <code>ARC</code> 机制自动控制。另外，在 <code>ARC</code> 环境中，<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/WorkingwithBlocks/WorkingwithBlocks.html" target="_blank" rel="external">官方其实对这个问题也有说明</a>：</p>
<blockquote>
<p>Note: You should specify copy as the property attribute, because a block needs to be copied to keep track of its captured state outside of the original scope. This isn’t something you need to worry about when using Automatic Reference Counting, as it will happen automatically, but it’s best practice for the property attribute to show the resultant behavior. </p>
</blockquote>
<p>所以，现在写代码，基本可以忽略 <code>Block</code> 必须使用 <code>copy</code> 的顾忌，因为系统会自动判断是不是需要将 <code>Block</code> 拷贝到堆区，这跟我们是否使用 <code>copy</code> 无关。</p>
<h4 id="问题-4-Block-的循环引用到底是怎么回事？"><a href="#问题-4-Block-的循环引用到底是怎么回事？" class="headerlink" title="问题 4. Block 的循环引用到底是怎么回事？"></a>问题 4. Block 的循环引用到底是怎么回事？</h4><p><code>Block</code> 的循环引用是怎么回事儿？看一个简单的例子：</p>
<figure class="highlight mm"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// AbstractComputer.m</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>(^blk_t)(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AbstractComputer</span>() </span>&#123;</span><br><span class="line">    <span class="built_in">NSInteger</span> _aIntegerInstance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) blk_t blk;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *aStringProperty;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">AbstractComputer</span></span></span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.blk = ^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%zd"</span>, _aIntegerInstance);</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="keyword">self</span>.aStringProperty);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>例子中，显而易见，<code>AbstractComputer</code> 类持有 <code>blk</code>，<code>clang</code> 之后，我们看 <code>blk</code> 的实现：</p>
<figure class="highlight mm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> __AbstractComputer__init_block_impl_0 &#123;</span><br><span class="line">	<span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">	<span class="keyword">struct</span> __AbstractComputer__init_block_desc_0* Desc;</span><br><span class="line">	AbstractComputer *<span class="keyword">self</span>;</span><br><span class="line">	__AbstractComputer__init_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __AbstractComputer__init_block_desc_0 *desc, AbstractComputer *_<span class="keyword">self</span>, <span class="keyword">int</span> flags=<span class="number">0</span>) : <span class="keyword">self</span>(_<span class="keyword">self</span>) &#123;</span><br><span class="line">		impl.isa = &amp;_<span class="built_in">NSConcreteStackBlock</span>;</span><br><span class="line">		impl.Flags = flags;</span><br><span class="line">		impl.FuncPtr = fp;</span><br><span class="line">		Desc = desc;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>blk</code> 的结构体中出现了 <code>AbstractComputer *self</code> 这一变量，而且是默认的修饰类型，所以 <code>blk</code> 也强引用了 <code>AbstractComputer</code>。所以就造成了循环引用。解决的办法也很简单，最普遍的做法是在 <code>blk</code> 定义之前声明 <code>__weak typeof(self) weakSelf = self;</code> 之后在 <code>blk</code> 内部使用 <code>weakSelf</code> 代替 <code>self</code>。文件中出现了 <code>__weak</code> 修饰符之后，<code>clang</code> 过不去，一直报错，所以没法对比了，不过猜想这时 <code>blk</code> 的结构体内部的 <code>weakSelf</code> 变量，应该是弱引用类型。</p>

      
    </div>

    <div>
      
        
      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/iOS/" rel="tag">#iOS</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/03/19/KVC-背后的流程/" rel="next" title="KVC 背后的执行流程">
                <i class="fa fa-chevron-left"></i> KVC 背后的执行流程
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2018/04/01/Block-背后的知识/"
           data-title="Block 几个问题--底层机制初探**" data-url="http://yoursite.com/2018/04/01/Block-背后的知识/">
      </div>
    
  </div>

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.png"
               alt="dalianer" />
          <p class="site-author-name" itemprop="name">dalianer</p>
          <p class="site-description motion-element" itemprop="description">大脸儿的成长记录</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">19</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">27</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/hexintao" target="_blank" title="github">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  github
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#问题-1-Block-的本质"><span class="nav-number">1.</span> <span class="nav-text">问题 1. Block 的本质</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问题-2-Block-捕获并修改外部变量"><span class="nav-number">2.</span> <span class="nav-text">问题 2. Block 捕获并修改外部变量</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-基本类型变量的捕获"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 基本类型变量的捕获</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-对象类型的捕获"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 对象类型的捕获</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问题-3-Block-为什么要用-copy-修饰符？"><span class="nav-number">3.</span> <span class="nav-text">问题 3. Block 为什么要用 copy 修饰符？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问题-4-Block-的循环引用到底是怎么回事？"><span class="nav-number">4.</span> <span class="nav-text">问题 4. Block 的循环引用到底是怎么回事？</span></a></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">dalianer—>You don’t change, you won’t change!</span>
</div>

<div class="powered-by">
  由 Hexo 强力驱动
</div>

<div class="theme-info">
  主题 -
    NexT.Mist
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"dalianer"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
      
      <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
      <script src="/js/src/hook-duoshuo.js"></script>
    
  





  
  
  

  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("qTC2lKnjgeMyQWqFztPA4ppN-gzGzoHsz", "CoPDrDN4NplhcYAjsrszCly9");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

</body>
</html>
