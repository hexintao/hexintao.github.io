<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="翻译,Objective-C,iOS,开发," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="原文地址：https://cocoasamurai.blogspot.jp/2010/01/understanding-objective-c-runtime.html
原文作者：Colin Wheeler
引子&amp;emsp;&amp;emsp;当人们谈到Objective-C/Cocoa时，Objective-C Runtime是一个非常容易被忽略掉的特点，这大概是因为OC语言本身是一门可以在一小段时间就">
<meta property="og:type" content="article">
<meta property="og:title" content="［翻译］理解Objective-C Runtime">
<meta property="og:url" content="http://yoursite.com/2016/05/17/OCRuntime/index.html">
<meta property="og:site_name" content="大脸儿">
<meta property="og:description" content="原文地址：https://cocoasamurai.blogspot.jp/2010/01/understanding-objective-c-runtime.html
原文作者：Colin Wheeler
引子&amp;emsp;&amp;emsp;当人们谈到Objective-C/Cocoa时，Objective-C Runtime是一个非常容易被忽略掉的特点，这大概是因为OC语言本身是一门可以在一小段时间就">
<meta property="og:image" content="http://yoursite.com/images/OCRuntime/ivars1.png">
<meta property="og:image" content="http://yoursite.com/images/OCRuntime/ivars2.png">
<meta property="og:image" content="http://yoursite.com/images/OCRuntime/ivars3.png">
<meta property="og:updated_time" content="2016-05-27T10:02:08.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="［翻译］理解Objective-C Runtime">
<meta name="twitter:description" content="原文地址：https://cocoasamurai.blogspot.jp/2010/01/understanding-objective-c-runtime.html
原文作者：Colin Wheeler
引子&amp;emsp;&amp;emsp;当人们谈到Objective-C/Cocoa时，Objective-C Runtime是一个非常容易被忽略掉的特点，这大概是因为OC语言本身是一门可以在一小段时间就">
<meta name="twitter:image" content="http://yoursite.com/images/OCRuntime/ivars1.png">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 6284716645889869000,
      author: '博主'
    }
  };
</script>

  <title> ［翻译］理解Objective-C Runtime | 大脸儿 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?3188724465a6f7695bd8b4ae49fbe857";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">大脸儿</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">hexintao</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                ［翻译］理解Objective-C Runtime
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-17T09:41:55+08:00" content="2016-05-17">
              2016-05-17
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Translations/" itemprop="url" rel="index">
                    <span itemprop="name">翻译</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/17/OCRuntime/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/17/OCRuntime/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2016/05/17/OCRuntime/" class="leancloud_visitors" data-flag-title="［翻译］理解Objective-C Runtime">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><strong>原文地址：</strong><a href="https://cocoasamurai.blogspot.jp/2010/01/understanding-objective-c-runtime.html" target="_blank" rel="external">https://cocoasamurai.blogspot.jp/2010/01/understanding-objective-c-runtime.html</a></p>
<p><strong>原文作者：</strong><a href="https://www.blogger.com/profile/16010768305821496589" target="_blank" rel="external">Colin Wheeler</a></p>
<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>&emsp;&emsp;当人们谈到Objective-C/Cocoa时，Objective-C Runtime是一个非常容易被忽略掉的特点，这大概是因为OC语言本身是一门可以在一小段时间就能入门的语言，学习Cocoa的新手们往往也只是在Cocoa框架和怎么使用框架上埋头钻研。可是，OC Runtime的工作原理是每一个学习OC的人都至少应该了解的，而并不是仅限于知道<code>[target doMethodWith:var1];</code>在经过编译之后变成了<code>objc_msgSend(target,@selector(doMethodWith:),var1);</code>这么表层的东西。理解了OC Runtime之后，有助于我们更深入的理解OC语言本身和应用的运行机制。在我看来，不论开发经验多或少，每一位Mac/iOS开发者都能从本文获取到一点新的知识。<br><a id="more"></a></p>
<h2 id="OC-Runtime开源项目"><a href="#OC-Runtime开源项目" class="headerlink" title="OC Runtime开源项目"></a>OC Runtime开源项目</h2><p>&emsp;&emsp;OC Runtime是一项开源项目，你可以从<a href="http://opensource.apple.comn" target="_blank" rel="external">http://opensource.apple.comn</a> 随时获得源代码。实际上，当初我刚开始去探究OC Runtime的工作机制时，相反，正是通过阅读它的源代码，而不是官方文档开始的。你也可以通过以下链接下载针对Mac OS X 10.6.2版本的Runtime源代码<a href="http://opensource.apple.com/tarballs/objc4/objc4-437.1.tar.gz" target="_blank" rel="external">objc4-437.1.tar.gz</a>。</p>
<h2 id="动态语言VS静态语言"><a href="#动态语言VS静态语言" class="headerlink" title="动态语言VS静态语言"></a>动态语言VS静态语言</h2><p>&emsp;&emsp;OC是一门运行时才定向的语言，这意味着到底该由哪个对象来执行消息是在经过编译、链接之后，待运行时才会被确定下来。这种动态性给我们提供了巨大而又灵活的应用空间，我们可以利用这个特点来实现一些平常不容易做到的操作，例如到运行时再将消息转发给需要其处理的对象，甚至还能交换两个对象的实现方法。正是由于这种灵活的动态性，我们在使用Runtime时，应该仔细检查每个对象所能处理或者不能处理但能正确转发的消息。而与此对应的C语言的运行机制则是：从<code>main()</code>函数开始，之后从上到下，按照写好的代码逻辑，顺序执行我们构造的功能函数，而且C语言中的结构体无法将函数的调用进行转发，例如如下所示的一段C语言代码：</p>
<figure class="highlight mm"><table><tr><td class="code"><pre><span class="line"><span class="meta">#include <span class="meta-string">&lt; stdio.h &gt;</span></span></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv[])</span><br><span class="line">&#123;</span><br><span class="line">        printf(<span class="string">"Hello World!"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在经过编译器编译之后，会变成如下的汇编代码：</p>
<figure class="highlight arm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">.text</span></span><br><span class="line"> <span class="meta">.align</span> <span class="number">4</span>,<span class="number">0x90</span></span><br><span class="line"> .globl _main</span><br><span class="line"><span class="symbol">_main</span>:</span><br><span class="line"><span class="symbol">Leh_func_begin1</span>:</span><br><span class="line"> <span class="keyword">pushq </span>%rbp</span><br><span class="line"><span class="symbol">Llabel1</span>:</span><br><span class="line"> <span class="keyword">movq </span>%rsp, %rbp</span><br><span class="line"><span class="symbol">Llabel2</span>:</span><br><span class="line"> <span class="keyword">subq </span><span class="number">$16</span>, %rsp</span><br><span class="line"><span class="symbol">Llabel3</span>:</span><br><span class="line"> <span class="keyword">movq </span>%rsi, %rax</span><br><span class="line"> <span class="keyword">movl </span>%edi, %ecx</span><br><span class="line"> <span class="keyword">movl </span>%ecx, -<span class="number">8</span>(%rbp)</span><br><span class="line"> <span class="keyword">movq </span>%rax, -<span class="number">16</span>(%rbp)</span><br><span class="line"> xorb %al, %al</span><br><span class="line"> leaq LC(%rip), %rcx</span><br><span class="line"> <span class="keyword">movq </span>%rcx, %rdi</span><br><span class="line"> call _printf</span><br><span class="line"> <span class="keyword">movl </span><span class="number">$0</span>, -<span class="number">4</span>(%rbp)</span><br><span class="line"> <span class="keyword">movl </span>-<span class="number">4</span>(%rbp), %eax</span><br><span class="line"> <span class="keyword">addq </span><span class="number">$16</span>, %rsp</span><br><span class="line"> <span class="keyword">popq </span>%rbp</span><br><span class="line"> ret</span><br><span class="line"><span class="symbol">Leh_func_end1</span>:</span><br><span class="line"> .cstring</span><br><span class="line"><span class="symbol">LC</span>:</span><br><span class="line"> <span class="meta">.asciz</span> <span class="string">"Hello World!"</span></span><br></pre></td></tr></table></figure>
<p>然后又经过链接，最终会生成一个可执行文件。这个过程和OC依赖OC Runtime库编译、链接程序的过程类似。例如下边一段OC代码：</p>
<figure class="highlight mm"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">self</span> doSomethingWithVar:var1];</span><br></pre></td></tr></table></figure>
<p>会被编译成：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">objc_msgSend(self,@selector(doSomethingWithVar:),var1);</span><br></pre></td></tr></table></figure>
<p>除了这一点，我们对于OC的Runtime的工作机制完全不知道。</p>
<h2 id="什么是OC-Runtime"><a href="#什么是OC-Runtime" class="headerlink" title="什么是OC Runtime"></a>什么是OC Runtime</h2><p>&emsp;&emsp;OC Runtime是一个Runtime库，它主要以C和汇编语言为基础，使用面向对象的OC来编写。这意味着，它可以加载类，也可以对消息进行转发、分发等。总而言之，OC Runtime为OC这门面向对象的语言提供了基础性的结构支持。</p>
<h2 id="OC-Runtime相关术语"><a href="#OC-Runtime相关术语" class="headerlink" title="OC Runtime相关术语"></a>OC Runtime相关术语</h2><p>&emsp;&emsp;在我们进行更深一步的探讨之前，先让我们共同梳理一下关于OC Runtime的术语。</p>
<h3 id="1-Runtime"><a href="#1-Runtime" class="headerlink" title="1.Runtime"></a>1.Runtime</h3><p>&emsp;&emsp;Mac/iOS开发人员关心的有2个运行时：现代运行时（Modern Runtime）和传统运行时（Legacy Runtime）。现代运行时涵盖了所有64位的Mac OS X和iPhone应用，而传统运行时则包括剩下的所有的32位Mac OS X应用。</p>
<h3 id="2-方法（Methods）"><a href="#2-方法（Methods）" class="headerlink" title="2.方法（Methods）"></a>2.方法（Methods）</h3><p>&emsp;&emsp;包括两类基本的方法：对象方法（以<code>&quot;-&quot;</code>开头，像<code>- (void)doFoo</code>）;类方法（以<code>&quot;+&quot;</code>开头，像<code>+(id)alloc</code>）。方法看起来和C语言中的函数很像，它们内部都是一段需要执行的语句，像下面这样：</p>
<figure class="highlight mm"><table><tr><td class="code"><pre><span class="line">-(<span class="built_in">NSString</span> *)movieTitle</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">@"Futurama: Into the Wild Green Yonder"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-选择器（selector）"><a href="#3-选择器（selector）" class="headerlink" title="3.选择器（selector）"></a>3.选择器（selector）</h3><p>&emsp;&emsp;OC中的选择器有点类似于C语言中的数据结构体，它扮演着确定需要执行的OC方法的角色。在Runtime中它的定义类似于下面这样：</p>
<figure class="highlight mm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_selector *SEL;</span><br></pre></td></tr></table></figure>
<p>使用时：</p>
<figure class="highlight mm"><table><tr><td class="code"><pre><span class="line">SEL aSel = <span class="keyword">@selector</span>(movieTitle);</span><br></pre></td></tr></table></figure>
<h3 id="4-消息（Message）"><a href="#4-消息（Message）" class="headerlink" title="4.消息（Message）"></a>4.消息（Message）</h3><figure class="highlight mm"><table><tr><td class="code"><pre><span class="line">[target getMovieTitleForObject:obj];</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;OC中的消息其实就是2个中括号中间的东西。它由接受消息的目标对象、需要执行的方法名和需要传入的参数三部分组成。OC消息类似于C语言的函数，但它们又不相同，给一个目标对象发送消息并不代表该对象就一定会执行这个方法，接受对象可以根据消息的发送者决定具体执行的方法，或者是该对象本身并不执行，而是将此消息转发给另一个对象去执行。</p>
<h3 id="5-类（class）"><a href="#5-类（class）" class="headerlink" title="5.类（class）"></a>5.类（class）</h3><p>&emsp;&emsp;在Runtime中，我们可以发现如下定义：</p>
<figure class="highlight mm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class *Class; </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_object &#123;	Class isa; </span><br><span class="line">&#125; *<span class="keyword">id</span>;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这里面传达出几点信息。首先这段代码中分别有类的结构体定义和对象的结构体定义；其次对象的结构体中有一个类指针<code>isa</code>，也就是我们平常所说的“<code>isa</code>指针”。isa指针的存在是为了在运行时检查一个对象的父类，然后在其父类对应的类方法列表中查询可以响应消息的方法。最后，代码的结尾处还有一个id指针。id指针默认是告诉我们这个对象只是一个OC对象，系统可以通过查询id指针指向对象所属的类，进而查询到它能否对消息做出响应。当然，如果id指针指向的对象一经确定，我们可以进行更多的操作。</p>
<h3 id="6-块（Blocks）"><a href="#6-块（Blocks）" class="headerlink" title="6.块（Blocks）"></a>6.块（Blocks）</h3><p>&emsp;&emsp;在LLVM/Clang文档中，关于blocks的介绍：<br><figure class="highlight mm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> Block_literal_1 &#123;</span><br><span class="line">    <span class="keyword">void</span> *isa; <span class="comment">// initialized to &amp;_NSConcreteStackBlock or &amp;_NSConcreteGlobalBlock</span></span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line">    <span class="keyword">int</span> reserved; </span><br><span class="line">    <span class="keyword">void</span> (*invoke)(<span class="keyword">void</span> *, ...);</span><br><span class="line">    <span class="keyword">struct</span> Block_descriptor_1 &#123;</span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> reserved; <span class="comment">// NULL</span></span><br><span class="line">     <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> size;  <span class="comment">// sizeof(struct Block_literal_1)</span></span><br><span class="line"> <span class="comment">// optional helper functions</span></span><br><span class="line">     <span class="keyword">void</span> (*copy_helper)(<span class="keyword">void</span> *dst, <span class="keyword">void</span> *src);</span><br><span class="line">     <span class="keyword">void</span> (*dispose_helper)(<span class="keyword">void</span> *src); </span><br><span class="line">    &#125; *descriptor;</span><br><span class="line">    <span class="comment">// imported variables</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;代码块（blocks）是用来与OC Runtime相配合的，它也可看作是OC对象，所以也能对retain、release、copy等消息做出响应。</p>
<h3 id="6-IMP实现方法（Method-Implementations）"><a href="#6-IMP实现方法（Method-Implementations）" class="headerlink" title="6.IMP实现方法（Method Implementations）"></a>6.IMP实现方法（Method Implementations）</h3><figure class="highlight mm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">id</span> (*IMP)(<span class="keyword">id</span> <span class="keyword">self</span>,SEL _cmd,...);</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;IMP是编译器为我们生成的指向实现方法的指针。如果是刚开始接触OC语言，并不需要了解IMP，不过我们现在讨论的是Runtime，稍后就可以看到Runtime中是如何执行IMP的。</p>
<h3 id="7-OC类（Objective-C-Classes）"><a href="#7-OC类（Objective-C-Classes）" class="headerlink" title="7.OC类（Objective-C Classes）"></a>7.OC类（Objective-C Classes）</h3><p>&emsp;&emsp;OC Classes中具体都有什么呢？一个最基本的类的实现就像下边这样：</p>
<figure class="highlight mm"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyClass</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line"><span class="comment">//vars</span></span><br><span class="line"><span class="built_in">NSInteger</span> counter;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//methods</span></span><br><span class="line">-(<span class="keyword">void</span>)doFoo;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>但是在Runtime中，系统需要记录更多信息：</p>
<figure class="highlight mm"><table><tr><td class="code"><pre><span class="line"><span class="meta">#if !__OBJC2__</span></span><br><span class="line">    Class super_class                                        OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name                                         OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="keyword">long</span> version                                             OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="keyword">long</span> info                                                OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="keyword">long</span> instance_size                                       OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="keyword">struct</span> objc_ivar_list *ivars                             OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="keyword">struct</span> objc_method_list **methodLists                    OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="keyword">struct</span> objc_cache *cache                                 OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="keyword">struct</span> objc_protocol_list *protocols                     OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line"><span class="meta">#endif</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;可以看到，一个OC类有对以下对象的引用：它的父类、它的名称、实例变量、方法、缓存以及协议。当一个OC类或一个OC对象需要对消息做出响应时，Runtime需要上述信息才能完成工作。</p>
<h2 id="是类还是其本身定义一个对象？如何实现的？"><a href="#是类还是其本身定义一个对象？如何实现的？" class="headerlink" title="是类还是其本身定义一个对象？如何实现的？"></a>是类还是其本身定义一个对象？如何实现的？</h2><p>&emsp;&emsp;我在之前说过，其实类也是对象。Runtime会将类看作是元类（MetaClass）的对象来处理。当我们向类发送一个消息，类似于<code>[NSObject alloc]</code>这样，其实类是作为元类的一个对象来接收消息的。同时，元类又可看作是根元类（RootMetaClass）的对象，例如一个继承自<code>NSObject</code>的类，它的类指针指向<code>NSObject</code>。所有的元类的类指针都指向根元类作为其父类，而且元类中还保存着其能做出响应的方法列表，当我们给一个类发送消息，就像<code>[NSObject alloc]</code>，其实是<code>objc_msgSend()</code>在<code>NSObjec</code>的元类的方法列表中查询能够对<code>alloc</code>做出相应的方法，然后让其执行。</p>
<h2 id="为什么我们要继承自苹果的类库？"><a href="#为什么我们要继承自苹果的类库？" class="headerlink" title="为什么我们要继承自苹果的类库？"></a>为什么我们要继承自苹果的类库？</h2><p>&emsp;&emsp;刚开始接触Cocoa开发时，一般总会从继承NSObject类开始写代码。继承苹果的类库可以给我们的开发带来的极大方便，我们也享受着这种方便。令人惊奇的是，我们与Runtime打交道，其实这时候就开始了。当我们给自定义的类创建一个实例对象时，一般会这样做：<br><figure class="highlight mm"><table><tr><td class="code"><pre><span class="line">MyObject *object = [[MyObject alloc] init];</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;<code>+alloc</code>是第一个被执行的消息。在<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSObject_Class/index.html" target="_blank" rel="external">这个文档</a>中，它是这样介绍这个过程的：新建对象的isa指针依据类的数据结构进行初始化，开辟新内存，将对象中其余的变量值置0。所以，继承苹果的类库时，我们不仅继承了一些很好的功能，同时也继承了类似上述可以轻松创建对象并初始化的过程，而且通过这个操作创建出来的对象都能和Runtime要求的数据结构相一致（例如对象的isa指针会自动指向自定义的类）。</p>
<h2 id="什么是类缓存（Class-Cache）？"><a href="#什么是类缓存（Class-Cache）？" class="headerlink" title="什么是类缓存（Class Cache）？"></a>什么是类缓存（Class Cache）？</h2><p>&emsp;&emsp;通过对对象的isa指针进行追踪，Runtime可以找到对象所能响应的所有方法。然而我们经常调用的却往往只是这些方法中的一小部分，所以对象在响应消息时，就没必要每次都查询所有的方法，类缓存的概念也因此而来。类缓存的工作原理大致是：当对象对一个消息做出响应时，系统就会将这个方法存入到类缓存中，等<code>objc_msgSend()</code>下次查询时，就会优先检查类缓存，因为系统会认为调用完一个方法之后很有可能下次会再调用相同的方法。让我们以此为基础思考一下以下代码的执行过程：</p>
<figure class="highlight mm"><table><tr><td class="code"><pre><span class="line">MyObject *obj = [[MyObject alloc] init];</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyObject</span></span></span><br><span class="line">-(<span class="keyword">id</span>)init &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">self</span> = [<span class="keyword">super</span> init])&#123;</span><br><span class="line">        [<span class="keyword">self</span> setVarA:@”blah”];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;上述代码大致分别执行了以下过程：</p>
<ol>
<li><code>[MyObject alloc]</code>最先执行，然而MyObject类并没有<code>+alloc</code>对应的实现方法，所以系统接着就会查询MyObject的父类——NSObject；</li>
<li>经过查询，NSObject可以对<code>+alloc</code>做出响应，接着系统会检查MyObjec类，并在内存中开辟一块与其数据结构相一致的内存，并将isa指针指向MyObject，完成对象的创建过程，并把<code>+alloc</code>存入NSObject对应的类缓存中；</li>
<li>到目前为止，系统执行的都还是类方法，接下来就该执行<code>-init</code>或者其他初始化操作的对象方法了，同样系统也会将<code>-init</code>方法存入到类缓存中；</li>
<li>接下来该执行<code>self = [super init]</code>了。super是一个指向父类的关键字，在这里，系统会查询NSObject的方法列表并执行其中的<code>init</code>方法。这一步的操作是为了确保OOP继承模型能正确工作，其原理大致是：首先应该正确初始化父类的相关变量，然后我们自定义的类（也就是子类）的变量才能够得到正确的初始化。如果有需要，我们也可以重写父类。不过在这个例子中，NSObject似乎没什么太大的作用，当然这只是特殊情况，有些时候，NSObject则承担着十分重要的初始化角色，例如：</li>
</ol>
<figure class="highlight mm"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt; Foundation/Foundation.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyObject</span> : <span class="title">NSObject</span></span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">NSString</span> *aString;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">@property</span>(retain) <span class="built_in">NSString</span> *aString;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyObject</span></span></span><br><span class="line"> </span><br><span class="line">-(<span class="keyword">id</span>)init</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">  [<span class="keyword">self</span> setAString:<span class="literal">nil</span>];</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">@synthesize</span> aString;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> main (<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="built_in">NSAutoreleasePool</span> * pool = [[<span class="built_in">NSAutoreleasePool</span> alloc] init];</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">id</span> obj1 = [<span class="built_in">NSMutableArray</span> alloc];</span><br><span class="line"> <span class="keyword">id</span> obj2 = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line">  </span><br><span class="line"> <span class="keyword">id</span> obj3 = [<span class="built_in">NSArray</span> alloc];</span><br><span class="line"> <span class="keyword">id</span> obj4 = [[<span class="built_in">NSArray</span> alloc] initWithObjects:<span class="string">@"Hello"</span>,<span class="literal">nil</span>];</span><br><span class="line">  </span><br><span class="line"> <span class="built_in">NSLog</span>(<span class="string">@"obj1 class is %@"</span>,<span class="built_in">NSStringFromClass</span>([obj1 class]));</span><br><span class="line"> <span class="built_in">NSLog</span>(<span class="string">@"obj2 class is %@"</span>,<span class="built_in">NSStringFromClass</span>([obj2 class]));</span><br><span class="line">  </span><br><span class="line"> <span class="built_in">NSLog</span>(<span class="string">@"obj3 class is %@"</span>,<span class="built_in">NSStringFromClass</span>([obj3 class]));</span><br><span class="line"> <span class="built_in">NSLog</span>(<span class="string">@"obj4 class is %@"</span>,<span class="built_in">NSStringFromClass</span>([obj4 class]));</span><br><span class="line">  </span><br><span class="line"> <span class="keyword">id</span> obj5 = [MyObject alloc];</span><br><span class="line"> <span class="keyword">id</span> obj6 = [[MyObject alloc] init];</span><br><span class="line">  </span><br><span class="line"> <span class="built_in">NSLog</span>(<span class="string">@"obj5 class is %@"</span>,<span class="built_in">NSStringFromClass</span>([obj5 class]));</span><br><span class="line"> <span class="built_in">NSLog</span>(<span class="string">@"obj6 class is %@"</span>,<span class="built_in">NSStringFromClass</span>([obj6 class]));</span><br><span class="line">  </span><br><span class="line"> [pool drain];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码的打印结果会是什么呢？如果你是刚接触Cocoa开发，有可能会这样回答：</p>
<figure class="highlight mm"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSMutableArray</span></span><br><span class="line"><span class="built_in">NSMutableArray</span> </span><br><span class="line"><span class="built_in">NSArray</span></span><br><span class="line"><span class="built_in">NSArray</span></span><br><span class="line">MyObject</span><br><span class="line">MyObject</span><br></pre></td></tr></table></figure>
<p>而实际却是这样：</p>
<figure class="highlight mm"><table><tr><td class="code"><pre><span class="line">obj1 class is __<span class="built_in">NSPlaceholderArray</span></span><br><span class="line">obj2 class is <span class="built_in">NSCFArray</span></span><br><span class="line">obj3 class is __<span class="built_in">NSPlaceholderArray</span></span><br><span class="line">obj4 class is <span class="built_in">NSCFArray</span></span><br><span class="line">obj5 class is MyObject</span><br><span class="line">obj6 class is MyObject</span><br></pre></td></tr></table></figure>
<p>原因是：在OC中，<code>＋alloc</code>会返回一个类的对象，而<code>-init</code>则会返回另一个类对象。</p>
<h2 id="objc-msgSend-执行了什么？"><a href="#objc-msgSend-执行了什么？" class="headerlink" title="objc_msgSend()执行了什么？"></a>objc_msgSend()执行了什么？</h2><p>执行了很多过程，让我们还是以一个例子开始：</p>
<figure class="highlight mm"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">self</span> printMessageWithString:<span class="string">@"HelloWorld!"</span>];</span><br></pre></td></tr></table></figure>
<p>经过编译之后，上述代码实际会变成：</p>
<figure class="highlight mm"><table><tr><td class="code"><pre><span class="line">objc_msgSend(<span class="keyword">self</span>,<span class="keyword">@selector</span>(printMessageWithString:),<span class="string">@"Hello World!"</span>);</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;通过对isa指针的跟踪，系统会查询接受对象（或其父类）能否对选择器（selector）做出响应，假如系统在类的分发表（class dispatch table）或者类缓存中，找到了对应方法，则系统就会跳转到对应方法的地址并开始执行。不过objc_msgSend()并不会返回消息，它开始执行之后只是通过指针找到对应的实现方法，然后由实现方法执行并完成返回，这看起来就跟是objc_msgSend()返回一样。关于这一点，Bill通过三部分（<a href="http://www.friday.com/bbum/2009/12/18/objc_msgsend-part-1-the-road-map/" target="_blank" rel="external">part1</a>、<a href="http://www.friday.com/bbum/2009/12/18/objc_msgsend-tour-part-2-setting-the-stage/" target="_blank" rel="external">part2</a>&amp;<a href="http://www.friday.com/bbum/2009/12/18/objc_msgsend-tour-part-3-the-fast-path/" target="_blank" rel="external">part3</a>）讲解的更为细致，他的意思大致是：在OC代码中，</p>
<ol>
<li>检查是否有可以被忽略或者被绕过不执行的选择器——显然，在运行有垃圾回收的机制下，类似于<code>-retain/-release</code>的操作都可以被忽略掉了；</li>
<li>检查有没有空（nil）对象。OC语言与其他语言不同，给nil对象发送消息完全合法，并且有些时候你也愿意这么做，不过在这里我们假设接收对象不为空，接下来……</li>
<li>系统在类中查询实现方法（IMP）。首先在类缓存中查询，如果找到了就直接跳转至对应的方法；</li>
<li>如果类缓存中没有要找的方法，系统就会转而查询类的分发表，如果在表中找到了就直接跳转至对应的方法；</li>
<li>如果在类缓存和分发表中都没有查询到对应的实现方法，系统就会启用消息转发机制。这意味着你的代码将会被编译器转换为C语言中的函数。假如你写了这样一个方法：</li>
</ol>
<figure class="highlight mm"><table><tr><td class="code"><pre><span class="line">-(<span class="keyword">int</span>)doComputeWithNum:(<span class="keyword">int</span>)aNum</span><br></pre></td></tr></table></figure>
<p>它将会被转换为：</p>
<figure class="highlight mm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> aClass_doComputeWithNum(aClass *<span class="keyword">self</span>,SEL _cmd,<span class="keyword">int</span> aNum)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;OC Runtime通过函数指针来调用你的函数，而你却不能直接调用这些被转换后的函数。不过Cocoa框架给我们提供了另外一个能获取到这些函数指针的方法：</p>
<figure class="highlight mm"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明一个C的函数指针</span></span><br><span class="line"><span class="keyword">int</span> (computeNum *)(<span class="keyword">id</span>,SEL,<span class="keyword">int</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//Cocoa中而不是OC Runtime中的方法</span></span><br><span class="line"><span class="comment">//取得和 objc_msgSend() 获取到的一样的函数指针</span></span><br><span class="line">computeNum = (<span class="keyword">int</span> (*)(<span class="keyword">id</span>,SEL,<span class="keyword">int</span>))[target methodForSelector:<span class="keyword">@selector</span>(doComputeWithNum:)];</span><br><span class="line"> </span><br><span class="line"><span class="comment">//执行Runtime返回的函数指针</span></span><br><span class="line">computeNum(obj,<span class="keyword">@selector</span>(doComputeWithNum:),aNum);</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;通过这种方式，你可以直接获取到函数并在Runtime中调用它，甚至可以以此绕过Runtime的动态机制，达到确定想执行某一个方法的目的。其实，OC Runtime也是通过这种方法来获取函数的地址的，只不过它是利用objc_msgSend()而已。</p>
<h2 id="OC消息转发"><a href="#OC消息转发" class="headerlink" title="OC消息转发"></a>OC消息转发</h2><p>&emsp;&emsp;在OC中，给一个不确定其能否做出响应的对象发送消息是合法的，甚至有时会故意这样做，对此，苹果给出的解释是：为了模拟OC本身并不支持的多继承的特性。这一点也是Runtime机制所必须的，它的工作原理大致如下：</p>
<ul>
<li>Runtime首先依次查询类缓存、分发表及所有的父类（类缓存及分发表），如果找不到对应的方法就会执行下一个步骤；</li>
<li>OC Runtime会调用自定义类中的<code>+(BOOL)resolveInstanceMethod:(SEL)aSel</code>方法，这是系统给我们的第一次补救的机会，通过实现上述方法我们可以在系统启用消息转发机制的第一步就告诉Runtime我们已经做出补救，具体实现时首先应定义一个函数：</li>
</ul>
<figure class="highlight mm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> fooMethod(<span class="keyword">id</span> obj, SEL _cmd)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">NSLog</span>(<span class="string">@"Doing Foo"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后将其添加到类方法：</p>
<figure class="highlight mm"><table><tr><td class="code"><pre><span class="line">+(<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)aSEL</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(aSEL == <span class="keyword">@selector</span>(doFoo:))&#123;</span><br><span class="line">        class_addMethod([<span class="keyword">self</span> class],aSEL,(IMP)fooMethod,<span class="string">"v@:"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>class_addMethod</code>最后的“v@”代表函数的返回类型和参数，可以通过Runtime手册中的<a href="https://developer.apple.com/library/mac/#DOCUMENTATION/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html" target="_blank" rel="external">TypeEncodings</a>来查看具体字符代表的含义；</p>
<ul>
<li>如果第2步中的补救没有解决问题，系统会给我们提供第二次机会处理无法解决的方法。这一步仍要比接下来的措施好一点，因为后续的补救措施将会更耗资源，原因在于下一个补救措施中将会创建新对象，并执行：</li>
</ul>
<figure class="highlight mm"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation;</span><br></pre></td></tr></table></figure>
<p>不过在这一步中，我们可以这样实现：</p>
<figure class="highlight mm"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(aSelector == <span class="keyword">@selector</span>(mysteriousMethod:))&#123;</span><br><span class="line">        <span class="keyword">return</span> alternateObject;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显然，不能再在这个方法里返回self，这会引起死循环。</p>
<ul>
<li>如果上述方法都不能解决问题，Runtime会尝试最后一次机会，调用<code>(void)forwardInvocation:(NSInvocation *)anInvocation;</code>NSInvocation是消息封装后的对象，在系统创建出NSInvocation对象之后，我们可以改变消息的接收对象、选择器和参数，就像这样：</li>
</ul>
<figure class="highlight mm"><table><tr><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)invocation</span><br><span class="line">&#123;</span><br><span class="line">    SEL invSEL = invocation.selector;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>([altObject respondsToSelector:invSEL]) &#123;</span><br><span class="line">        [invocation invokeWithTarget:altObject];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [<span class="keyword">self</span> doesNotRecognizeSelector:invSEL];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight mm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> fooMethod(<span class="keyword">id</span> obj, SEL _cmd)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">NSLog</span>(<span class="string">@"Doing Foo"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后将其添加到类方法：</p>
<figure class="highlight mm"><table><tr><td class="code"><pre><span class="line">+(<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)aSEL</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(aSEL == <span class="keyword">@selector</span>(doFoo:))&#123;</span><br><span class="line">        class_addMethod([<span class="keyword">self</span> class],aSEL,(IMP)fooMethod,<span class="string">"v@:"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>class_addMethod</code>最后的“v@”代表函数的返回类型和参数，可以通过Runtime手册中的<a href="https://developer.apple.com/library/mac/#DOCUMENTATION/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html" target="_blank" rel="external">TypeEncodings</a>来查看具体字符代表的含义；如果自定义的类是继承自NSObject，则应实现的方法是：<code>- (void)forwardInvocation:(NSInvocation *)anInvocation</code>。最后，我们可以重写<code>-doesNotRecognizeSelector:</code>方法来做最后一点能做的事情，因为下一步程序就会崩溃。</p>
<p><strong>译者注：这一步，一定要实现<code>-methodSignatureForSelector:</code>这个方法，返回函数的签名类型，即上一步中提到的“v@”，否则<code>-(void)forwardInvocation</code>不会执行！</strong></p>
<h2 id="并不脆弱的变量（现代运行时，ModernRuntime）"><a href="#并不脆弱的变量（现代运行时，ModernRuntime）" class="headerlink" title="并不脆弱的变量（现代运行时，ModernRuntime）"></a>并不脆弱的变量（现代运行时，ModernRuntime）</h2><p>&emsp;&emsp;我们最近才从现代运行时中认识到的一点：并不脆弱的变量（Non Fragile ivars）。编译时，我们定义的变量是以在类中的偏移地址访问的，而且这些工作编译器能自动帮我们完成，这牵扯到底层的细节，大致类似于：先得到一个指针指向创建的对象，然后基于该对象的起始地址，再根据变量的偏移地址我们就可以访问到变量，最后根据变量的类型确定变量所占的内存空间，所以编译后变量的输出形式（ivar layout）类似于下边的表格，左边一列数字代表偏移地址：<br><img src="/images/OCRuntime/ivars1.png" alt="变量输出"><br>在苹果给出Mac OS X10.x更新之前，这一直都运行良好，可在更新之后，我们自定义的类中因为有些部分与父类发生了重叠，重叠的部分会被系统擦除，<img src="/images/OCRuntime/ivars2.png" alt="变量擦除">唯一的解决办法是苹果还会到以前的布局方式，不过如果苹果这样做的话，意味着他们的框架就会因为其变量定义被冻结而不能与时俱进，在这种“脆弱变量”的机制下，我们不得不重新编译，以使自定义的类继承到父类已经保留的部分。</p>
<p>不过在“不脆弱变量”的机制下，又发生了什么呢？<br><img src="/images/OCRuntime/ivars3.png" alt="不脆弱的变量">这种情况下，编译器会自动生成与“脆弱变量”机制下完全一样的布局，不过当Runtime检测到与父类有重叠的部分时，它会在自定义类中自动调整变量的偏移地址，从而保存自定义类的变量。</p>
<h2 id="OC关联对象"><a href="#OC关联对象" class="headerlink" title="OC关联对象"></a>OC关联对象</h2><p>&emsp;&emsp;在Mac OS X10.6中新引入的一个名词是——关联引用。OC并不支持像其他语言中的动态添加变量的功能，所以在这之前，我们不得不努力为将来有可能用到的变量预留出足够的空间，而从Mac OS X10.6开始，OC已经原生支持这一点了。假如我们想为现有的类，比如NSView添加变量，可以：</p>
<figure class="highlight mm"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt; Cocoa/Cocoa.h&gt;</span> //Cocoa</span></span><br><span class="line"><span class="meta">#include <span class="meta-string">&lt; objc/runtime.h&gt;</span> //objc runtime api’s</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSView</span> (<span class="title">CustomAdditions</span>)</span></span><br><span class="line"><span class="keyword">@property</span>(retain) <span class="built_in">NSImage</span> *customImage;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSView</span> (<span class="title">CustomAdditions</span>)</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> img_key; <span class="comment">//has a unique address (identifier)</span></span><br><span class="line"> </span><br><span class="line">-(<span class="built_in">NSImage</span> *)customImage</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>,&amp;img_key);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">-(<span class="keyword">void</span>)setCustomImage:(<span class="built_in">NSImage</span> *)image</span><br><span class="line">&#123;</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>,&amp;img_key,image,</span><br><span class="line">                             OBJC_ASSO<span class="built_in">CIATION_RETAIN</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>在Runtime.h中我们可以找到传递给<code>objc_setAssociatedObject()</code>的选项，</p>
<figure class="highlight mm"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Associated Object support. */</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* objc_setAssociatedObject() options */</span></span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    OBJC_ASSO<span class="built_in">CIATION_ASSIGN</span> = <span class="number">0</span>,</span><br><span class="line">    OBJC_ASSO<span class="built_in">CIATION_RETAIN_NONATOMIC</span> = <span class="number">1</span>,</span><br><span class="line">    OBJC_ASSO<span class="built_in">CIATION_COPY_NONATOMIC</span> = <span class="number">3</span>,</span><br><span class="line">    OBJC_ASSO<span class="built_in">CIATION_RETAIN</span> = <span class="number">01401</span>,</span><br><span class="line">    OBJC_ASSO<span class="built_in">CIATION_COPY</span> = <span class="number">01403</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>objc_setAssociatedObject()</code>的参数和<code>@property</code>类似。</p>
<h2 id="混合vTable分发"><a href="#混合vTable分发" class="headerlink" title="混合vTable分发"></a>混合vTable分发</h2><p>&emsp;&emsp;在现代运行时的<a href="http://opensource.apple.com/source/objc4/objc4-437/runtime/objc-runtime-new.m" target="_blank" rel="external">源代码</a>中，有以下代码：</p>
<figure class="highlight mm"><table><tr><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span><br><span class="line">* vtable dispatch</span><br><span class="line">* </span><br><span class="line">* Every class gets a vtable pointer. The vtable is an array of IMPs.</span><br><span class="line">* The selectors represented in the vtable are the same for all classes</span><br><span class="line">*   (i.e. no class has a bigger or smaller vtable).</span><br><span class="line">* Each vtable index has an associated trampoline which dispatches to </span><br><span class="line">*   the IMP at that index for the receiver class's vtable (after </span><br><span class="line">*   checking for NULL). Dispatch fixup uses these trampolines instead </span><br><span class="line">*   of objc_msgSend.</span><br><span class="line">* Fragility: The vtable size and list of selectors is chosen at launch </span><br><span class="line">*   time. No compiler-generated code depends on any particular vtable </span><br><span class="line">*   configuration, or even the use of vtable dispatch at all.</span><br><span class="line">* Memory size: If a class's vtable is identical to its superclass's </span><br><span class="line">*   (i.e. the class overrides none of the vtable selectors), then </span><br><span class="line">*   the class points directly to its superclass's vtable. This means </span><br><span class="line">*   selectors to be included in the vtable should be chosen so they are </span><br><span class="line">*   (1) frequently called, but (2) not too frequently overridden. In </span><br><span class="line">*   particular, -dealloc is a bad choice.</span><br><span class="line">* Forwarding: If a class doesn't implement some vtable selector, that </span><br><span class="line">*   selector's IMP is set to objc_msgSend in that class's vtable.</span><br><span class="line">* +initialize: Each class keeps the default vtable (which always </span><br><span class="line">*   redirects to objc_msgSend) until its +initialize is completed.</span><br><span class="line">*   Otherwise, the first message to a class could be a vtable dispatch, </span><br><span class="line">*   and the vtable trampoline doesn't include +initialize checking.</span><br><span class="line">* Changes: Categories, addMethod, and setImplementation all force vtable </span><br><span class="line">*   reconstruction for the class and all of its subclasses, if the </span><br><span class="line">*   vtable selectors are affected.</span><br><span class="line">**********************************************************************/</span></span><br></pre></td></tr></table></figure>
<p>这背后的思想是：vTable中保存着最经常被调用的选择器，因为这是用比objc_msgSend()更少的指令，所以可以提高应用的运行速度。在vTable中保存着16个最经常被调用的选择器，再往下，我们会看到在默认的有垃圾回收机制的vTable和没有开启垃圾回收机制的vTable：</p>
<figure class="highlight mm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> defaultVtable[] = &#123;</span><br><span class="line">    <span class="string">"allocWithZone:"</span>, </span><br><span class="line">    <span class="string">"alloc"</span>, </span><br><span class="line">    <span class="string">"class"</span>, </span><br><span class="line">    <span class="string">"self"</span>, </span><br><span class="line">    <span class="string">"isKindOfClass:"</span>, </span><br><span class="line">    <span class="string">"respondsToSelector:"</span>, </span><br><span class="line">    <span class="string">"isFlipped"</span>, </span><br><span class="line">    <span class="string">"length"</span>, </span><br><span class="line">    <span class="string">"objectForKey:"</span>, </span><br><span class="line">    <span class="string">"count"</span>, </span><br><span class="line">    <span class="string">"objectAtIndex:"</span>, </span><br><span class="line">    <span class="string">"isEqualToString:"</span>, </span><br><span class="line">    <span class="string">"isEqual:"</span>, </span><br><span class="line">    <span class="string">"retain"</span>, </span><br><span class="line">    <span class="string">"release"</span>, </span><br><span class="line">    <span class="string">"autorelease"</span>, </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> defaultVtableGC[] = &#123;</span><br><span class="line">    <span class="string">"allocWithZone:"</span>, </span><br><span class="line">    <span class="string">"alloc"</span>, </span><br><span class="line">    <span class="string">"class"</span>, </span><br><span class="line">    <span class="string">"self"</span>, </span><br><span class="line">    <span class="string">"isKindOfClass:"</span>, </span><br><span class="line">    <span class="string">"respondsToSelector:"</span>, </span><br><span class="line">    <span class="string">"isFlipped"</span>, </span><br><span class="line">    <span class="string">"length"</span>, </span><br><span class="line">    <span class="string">"objectForKey:"</span>, </span><br><span class="line">    <span class="string">"count"</span>, </span><br><span class="line">    <span class="string">"objectAtIndex:"</span>, </span><br><span class="line">    <span class="string">"isEqualToString:"</span>, </span><br><span class="line">    <span class="string">"isEqual:"</span>, </span><br><span class="line">    <span class="string">"hash"</span>, </span><br><span class="line">    <span class="string">"addObject:"</span>, </span><br><span class="line">    <span class="string">"countByEnumeratingWithState:objects:count:"</span>, </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;可我们怎么知道自己是不是从vTable中调用了这些方法呢？调试时，我们会看到以下几种方法：<br><code>objc_msgSend_fixup</code>：代表该方法并没有从vTable中调用；<br><code>objc_msgSend_fixedup</code>：代表调用了一开始在vTable中现在却已不存在的方法；<br><code>objc_msgSend_vtable[0-15]</code>：代表调用了vTable中的某一个方法，后边的数字代表该方法在vTable中的序号。</p>
<p>&emsp;&emsp;Runtime会自动调整vTable中方法的顺序，所以这次有可能<code>objc_msgSend_vtable10</code>对应着<code>-length</code>方法，但下次运行时，不要指望它俩还是对应着的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;我希望你能喜欢这篇文章，这也是我在Des Moines Cocoaheads演讲中的内容。OC Runtime是一项浩大的工程，它为我们的Cocoa／OC应用提供了动力，同时也让我们习以为常的功能得以实现，如果你还没有浏览过苹果的<a href="https://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html" target="_blank" rel="external">官方文档</a>，希望你能浏览一下，以便能够更好的利用OC Runtime。再次感谢你的阅读！</p>

      
    </div>

    <div>
      
        
      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/翻译/" rel="tag">#翻译</a>
          
            <a href="/tags/Objective-C/" rel="tag">#Objective-C</a>
          
            <a href="/tags/iOS/" rel="tag">#iOS</a>
          
            <a href="/tags/开发/" rel="tag">#开发</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/05/14/iOS单元格未注册/" rel="next" title="iOS开发之——iOS单元格未注册">
                <i class="fa fa-chevron-left"></i> iOS开发之——iOS单元格未注册
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/05/24/nil:Nil:NULL:NSNull/" rel="prev" title="［翻译］nil/Nil/NULL/NSNull">
                ［翻译］nil/Nil/NULL/NSNull <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2016/05/17/OCRuntime/"
           data-title="［翻译］理解Objective-C Runtime" data-url="http://yoursite.com/2016/05/17/OCRuntime/">
      </div>
    
  </div>

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.png"
               alt="dalianer" />
          <p class="site-author-name" itemprop="name">dalianer</p>
          <p class="site-description motion-element" itemprop="description">大脸儿的成长记录</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">12</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">22</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/hexintao" target="_blank" title="github">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  github
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#引子"><span class="nav-number">1.</span> <span class="nav-text">引子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#OC-Runtime开源项目"><span class="nav-number">2.</span> <span class="nav-text">OC Runtime开源项目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#动态语言VS静态语言"><span class="nav-number">3.</span> <span class="nav-text">动态语言VS静态语言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是OC-Runtime"><span class="nav-number">4.</span> <span class="nav-text">什么是OC Runtime</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#OC-Runtime相关术语"><span class="nav-number">5.</span> <span class="nav-text">OC Runtime相关术语</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-Runtime"><span class="nav-number">5.1.</span> <span class="nav-text">1.Runtime</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-方法（Methods）"><span class="nav-number">5.2.</span> <span class="nav-text">2.方法（Methods）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-选择器（selector）"><span class="nav-number">5.3.</span> <span class="nav-text">3.选择器（selector）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-消息（Message）"><span class="nav-number">5.4.</span> <span class="nav-text">4.消息（Message）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-类（class）"><span class="nav-number">5.5.</span> <span class="nav-text">5.类（class）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-块（Blocks）"><span class="nav-number">5.6.</span> <span class="nav-text">6.块（Blocks）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-IMP实现方法（Method-Implementations）"><span class="nav-number">5.7.</span> <span class="nav-text">6.IMP实现方法（Method Implementations）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-OC类（Objective-C-Classes）"><span class="nav-number">5.8.</span> <span class="nav-text">7.OC类（Objective-C Classes）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#是类还是其本身定义一个对象？如何实现的？"><span class="nav-number">6.</span> <span class="nav-text">是类还是其本身定义一个对象？如何实现的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么我们要继承自苹果的类库？"><span class="nav-number">7.</span> <span class="nav-text">为什么我们要继承自苹果的类库？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是类缓存（Class-Cache）？"><span class="nav-number">8.</span> <span class="nav-text">什么是类缓存（Class Cache）？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#objc-msgSend-执行了什么？"><span class="nav-number">9.</span> <span class="nav-text">objc_msgSend()执行了什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#OC消息转发"><span class="nav-number">10.</span> <span class="nav-text">OC消息转发</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#并不脆弱的变量（现代运行时，ModernRuntime）"><span class="nav-number">11.</span> <span class="nav-text">并不脆弱的变量（现代运行时，ModernRuntime）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#OC关联对象"><span class="nav-number">12.</span> <span class="nav-text">OC关联对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#混合vTable分发"><span class="nav-number">13.</span> <span class="nav-text">混合vTable分发</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">14.</span> <span class="nav-text">总结</span></a></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">dalianer—>You don’t change, you won’t change!</span>
</div>

<div class="powered-by">
  由 Hexo 强力驱动
</div>

<div class="theme-info">
  主题 -
    NexT.Mist
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"dalianer"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
      
      <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
      <script src="/js/src/hook-duoshuo.js"></script>
    
  





  
  
  

  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("qTC2lKnjgeMyQWqFztPA4ppN-gzGzoHsz", "CoPDrDN4NplhcYAjsrszCly9");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

</body>
</html>
